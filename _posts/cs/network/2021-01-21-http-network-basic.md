---
title: "[그림으로 배우는 HTTP & Network Basic] 요약 정리"
excerpt: "그림으로 배우는 HTTP & Network Basic(우에노 센 저)을 읽고 요약 정리한다."
categories:
  - Network
tags:
  - Network
  - 도서
date: 2021-01-22
last_modified_at: 2021-01-22
---

## 1. 서론

![image](https://user-images.githubusercontent.com/56240505/105327929-da813680-5c12-11eb-895b-b0efd304c248.png)

HTTP 통신에 대한 개요 및 주요 개념들을 그림으로 설명하고 있는 책입니다. 클라이언트-서버 모델을 비롯한 전반적인 HTTP 네트워크 플로우를 가볍게 공부하기 좋습니다. 네트워크를 입문하는데 A Top-Down Approach같은 두꺼운 전공 서적이 부담된다면 이 책을 추천드립니다. 🙃

<br>

## 2. 웹과 네트워크의 기본에 대해 알아보자

#### WWW(World Wide Web)

WWW(이하 웹)은 물리적으로 멀리 떨어져 있는 정보를 공용하게 할 수 있는 시스템이다. 여러 문서를 상호간에 관련 짓는 HyperText에 의해 상호간에 참조할 수 있다. WWW을 구성하는 기술은 다음과 같다.

* HTML(HyperText Markup Language) : 문서 기술 언어이다.
* HTTP(HyperText Transfer Protocol) : 문서 전송에 관한 통신 규약이다.
* URL(Uniform Resource Locator) : 문서의 주소를 지정하는 방법이다.

WWW은 초기에 웹 브라우저였으나, 현재에는 인터넷에 연결된 디바이스를 통해 사람들이 정보를 공유할 수 있는 일련의 시스템을 지칭한다.

#### HTTP

HTTP는 클라이언트와 서버가 데이터를 주고받을 수 있도록 약속한 소통 규칙이다. HTTP/1.1을 가장 많이 사용하며 HTTP/2.0까지 책정되어 있다. HTTP는 기술 사양을 정한 RFC 문서가 있으나, 일부 클라이언트나 서버는 RFC 사양대로 HTTP를 구현하지 않고 독자적인 사양을 사용한다.

#### TCP/IP

TCP/IP란 IP 프로토콜을 사용한 통신에서 사용되고 있는 인터넷 관련 프로토콜을 총칭한다. TCP/IP는 여러 계층으로 계층화되어 있다. 모듈화처럼 외부 변경에 의한 영향의 파급력을 낮춤으로써 유지보수가 편해지고, 각 계층은 내부를 자유롭고 독립적으로 설계할 수 있다.

* 어플리케이션 계층 : HTTP, DNS, FTP 등 어플리케이션에서 사용하는 통신의 움직임을 결정한다.
* 트랜스포트 계층 : UDP, TCP 등 네트워크로 접속된 2대의 호스트 사이의 데이터 흐름을 제공한다.
* 네트워크(인터넷) 계층 : 네트워크 상에서 라우팅 분석 등 패킷의 이동을 다룬다.
* 링크 계층 : 네트워크에 접속하는 하드웨어(NIC, 케이블 등) 측면을 다룬다.

네트워크 상의 각 노드들은 IP라는 변경가능한 논리적인 주소와 MAC이라는 변경불가능한 물리적인 주소를 가지고 있다. 라우팅으로 경로 상 다음 Hop에 위치한 노드의 IP 주소를 확인하고, ARP(Address Resolution Protocol)을 이용해 해당 다음 노드의 MAC 주소를 식별함으로써 데이터는 1개 Hop을 이동하게 된다. 이러한 작업의 반복을 통해 데이터는 목적지에 도착할 수 있다.

TCP는 Three Way Handshaking 및 Segment 분할을 통해 신뢰성 있는 바이트 스트림 서비스를 제공한다. DNS는 IP 주소와 도메인 이름간의 맵핑 정보를 제공한다.

#### URI(Uniform Resource Identifiers)

* Uniform : 통일된 서식을 결정하는 것으로, 여러 가지 종류의 리소스 지정 방법을 같은 맥락에서 구별없이 취급한다.
  * 이를 통해 새로운 스키마(http:와 ftp: 등) 도입이 용이해진다.
* Resource : 각종 파일 등 식별 가능한 모든 것이다.
* Identifier : 식별 가능한 것을 참조하는 오브젝트이며 식별자라고 한다.

URI는 스키마를 나타내는 리소스를 식별하기 위한 식별자(문자열 전반)이다. 스키마는 리소스를 얻기 위한 수단(프로토콜 등)에 이름을 붙이는 방법이다. URL은 URI의 서브셋으로서 리소스의 네트워크 상의 장소를 나타낸다.

<br>

## 3. 간단한 프로토콜 HTTP

#### HTTP 특징

HTTP는 클라이언트가 요청하면 서버가 응답하는 방식으로 통신한다. 서버 측은 요청을 수신하지 않으면 응답을 발생하지 않는다. HTTP는 다음과 같은 일반적인 특징이 있다.

* HTTP는 이전의 상태를 유지하지 않는 Stateless 프로토콜이다.
  * 쿠키를 통해 이전 상태를 확인할 수 있다.
    * 서버가 클라이언트 브라우저에게 Set-Cookie 헤더로 쿠키를 발급한다.
    * 클라이언트는 요청 헤더에 Cookie 값을 첨부함으로써 서버는 클라이언트와 이전 정보를 식별할 수 있다.
* HTTP는 리퀘스트 URI로 리소스를 식별한다.

초기 HTTP는 통신을 한 번 할 때마다 TCP 연결을 새로 맺어야 하는 단점이 있었다. 요청에 대한 응답이 도착하면 TCP가 자동으로 종료되기 때문이었다. 전달해야 할 리소스의 양이 많아질수록 연결-종료 요청 반복으로 인한 오버헤드가 심해졌다.

* 지속 연결(Persistent Connections) : 어느 한 쪽이 명시적으로 TCP 연결을 종료하지 않는 이상 TCP 연결이 계속 유지된다.
* 파이프라이닝(Pipelining) : 리퀘스트 송신 후에 리스폰스를 기다리지 않고 다음 여러 리퀘스트를 병행해서 보낸다.

위 방법들을 이용해서 오버헤드를 줄이고 리퀘스트를 더 빠르게 처리할 수 있다.

#### HTTP/1.1 메서드 목록

* GET : 리소스를 획득한다.
* POST : 엔티티를 전송한다.
* HEAD : 개발 단계에서 주로 사용하며 GET과 같지만 메시지 바디는 반환하지 않는다.
* PUT : 파일 전송과 같이 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구한다.
* DELETE : 리퀘스트 URI로 지정된 리소스의 삭제를 요구한다.
  * PUT과 DELETE는 자체 인증 기능이 없기 때문에 일반 웹 사이트에서는 사용되지 않는다.
* OPTIONS : 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드 목록을 확인한다.
* TRACE : 웹 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백을 발생한다.
  * Max-Forwards 헤더 필드에 수치가 주어지고, 프록시 서버 등을 통과할 때마다 수치가 줄어든다.
  * 수치가 0이 된 곳을 끝으로 리퀘스트를 마지막으로 수신한 곳에서 200 OK 상태 코드를 반환한다.
  * 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있다.
  * 크로스 사이트 트레이싱(XST) 공격 등 보안 상의 문제가 있어 사용하지 않는다.
* CONNECT : 프록시에 터널 접속 확립을 요구함으로써 TCP 통신을 터널링한다.
  * SSL, TLS 등 암호화된 것을 주로 터널링한다.

<br>

## 4. HTTP 정보는 HTTP 메시지에 있다

#### HTTP 메시지

HTTP 메시지는 HTTP 통신의 기본 단위이며, 복수 행의 데이터로 구성된 텍스트 문자열이다. 메시지는 메시지 헤더와 메시지 바디로 구분된다. 최초에 나타나는 개행 문자(CRLF)가 헤더와 바디를 구분한다. 메시지 바디는 Optional하다.

* 요청 메시지의 헤더 : 리퀘스트 라인, 리퀘스트 헤더 필드, 일반 헤더 필드, 엔터티 헤더 필드 등.
* 응답 메시지의 헤더 : 상태 라인, 리스폰스 헤더 필드, 일반 헤더 필드, 엔티티 헤더 필드 등.
* 엔티티(Entity) : 요청 및 응답의 페이로드로 전송되는 정보이다.
  * 엔티티 헤더 필드와 엔티티 바디로 구성된다.
  * HTTP 메시지 바디는 엔티티 바디를 운반한다.

#### Encoding

HTTP로 데이터를 전송할 때 인코딩을 통해 다량의 액세스 전송 효율을 높일 수 있다. 단, 인코딩 처리로 인해 CPU 리소스 사용이 증가한다.

* 컨텐츠 코딩 : 엔티티 정보를 유지한채 작게 압축하여 전송한다.
* 청크 전송 코딩 : 엔티티 바디를 분할하여 전송한다.

#### Multipart

HTTP는 멀티파트를 통해 하나의 메시지 바디 내부에 엔티티(텍스트, 이미지)를 여러 개 포함시켜 보낼 수 있다. 헤더에 Boundary 문자열로 멀티파트 각각의 엔티티 정보를 구분한다. 또한 Range Request 헤더 필드를 통해 리소스 엔티티의 특정 바이트 범위를 지정해서 다운받을 수 있다.

#### Content Negotiation

클라이언트와 서버가 제공하는 리소스의 내용에 대해서 교섭하는 것이다.

* 같은 URI에 접근하더라도 브라우저마다 서로 다른 언어의 페이지를 확인할 수 있다.
  * 인코딩 및 언어 등 요청 메시지 헤더의 필드를 기준으로 판단한다.
* 서버 구동형, 에이전트 구동형, 트랜스페어런트 등 총 3가지 방식의 네고시에이션 방식이 있다.

<br>

## 5. 결과를 전달하는 HTTP 상태 코드

상태 코드는 리퀘스트의 결과를 전달한다. 상태 코드가 현재 상황과 불일치할 수도 있다. 자세한 내용은 서적 혹은 RFC 문서를 참고하자.

* 2XX Success.
* 3XX Redirection.
  * 303 See Other는 다른 URI를 GET하라는 의미를 302 Found보다 명확하게 보여준다.
* 4XX Client Error.
  * 401 Unauthorized 인증은 후술한다.
* 5XX Server Error.

<br>

## 6. HTTP와 연계하는 웹 서버

#### Virtual Host

HTTP에서 1개의 물리적인 서버는 여러 개의 가상 호스트를 실행할 수 있다. 각 호스트들은 서로 다른 도메인 이름을 가지고 있으나, DNS는 해당 도메인 이름들을 모두 같은 아이피로 변환한다. 따라서 요청 메시지를 보낼 때 서버의 도메인 주소 뿐만 아니라 호스트명을 URL 혹은 Host 헤더 필드에 명시해야 한다.

#### 통신 중계 프로그램

* Proxy.
  * 클라이언트와 오리진 서버 사이에서 요청 및 응답이 경유하는 중계 서버이다.
  * 메시지가 여러 프록시 서버를 경유할 때 Via 헤더 필드에 경유한 서버의 정보가 기록된다.
  * 캐싱, 조직 내 특정 액세스 제한, 액세스 로그 획득 등 다양한 목적으로 사용된다.
  * 요청과 응답을 중계하면서 프록시 서버가 메시지를 변경할 수 있다.
* Gateway.
  * Proxy와 동작 방식이 유사하다.
  * 클라이언트와 게이트웨이는 HTTP로 통신하며, 게이트웨이 다음에 있는 서버는 HTTP 서버 이외의 서비스를 제공하는 서버다.
    * 게이트웨이가 DB에 접속해 SQL을 사용하거나 결제 시스템과 연동하는 것 등이 대표적인 사례다.
* Tunnel.
  * SSL 등 요구에 따라서 클라이언트와 서버 사이의 안전한 통신 경로를 확보한다.

#### Cache

캐시란 프록시 서버 혹은 클라이언트의 로컬 디스크에 저장된 리소스의 사본이다. 서버가 특정 리소스에 대한 최초 응답을 보낼 때, 리소스의 사본을 프록시 서버에 저장해둔다. 이후 동일한 리소스 요청이 발생하면 오리진 서버에 접근할 필요 없이 클라이언트와 가까운 프록시 서버가 요청을 처리해준다.

* 캐싱을 통해 리소스를 가진 오리진 서버로 향하는 액세스 트래픽을 줄일 수 있다.
* 캐싱 사본의 유효 기간이 만료되거나 최신성에 대한 클라이언트 요구가 있다면 프록시 서버는 오리진 서버로 리소스에 대해 Conditional Get을 수행한다.
* 클라이언트의 브라우저에도 임시 파일과 같은 캐시가 유사한 원리로 작동한다.

<br>

## 7. HTTP 헤더

> 각 헤더 필드에 대한 세부 설명은 서적이나 RFC 문서를 참고하자.<br>
[HTTP (6)- HTTP 헤더](https://medium.com/@ramkid91/http-6-http-%ED%97%A4%EB%8D%94-b98bba1d2229) 블로그에 헤더 필드의 종류가 도표로 잘 정리되어 있다.

#### HTTP 메시지 헤더

HTTP 메시지 헤더는 요청/상태 라인과 HTTP 헤더 필드로 이루어져 있다. HTTP 헤더 필드는 요청 및 응답 메시지의 헤더에 모두 존재한다. HTTP 헤더 필드의 특징은 다음과 같다.

* 메시지 바디의 크기와 인증 및 언어 등의 정보를 브라우저 혹은 서버에게 제공하는 역할을 한다.
* 각 헤더 필드는 콜론(:)을 기준으로 하는 Key-Value 형식을 따른다.
* 헤더 필드가 중복되는 경우 처리하는 방식은 브라우저 사양마다 상이하다.

#### HTTP 헤더 필드

HTTP 헤더 필드는 크게 4가지로 분류된다.

* 일반 헤더 필드 : 요청 및 응답 메시지가 모두 사용한다.
* 엔티티 헤더 필드 : 요청 및 응답 메시지 본문에 포함된 엔티티를 위해 사용된다.
* 요청 헤더 필드.
* 응답 헤더 필드.

HTTP 헤더 필드는 캐시와 비캐시 프록시의 동작을 정의하기 위해 두 가지 카테고리로 분류될 수 있다.

* End-to-End 헤더 : 이 카테고리의 헤더는 요청이나 응답의 최종 수신자에게 전송된다.
* Hop-by-Hop 헤더 : 이 카테고리의 헤더는 한 번 전송에 대해서만 유효하고 캐시 혹은 프록시에 의해서 전송되지 않는 것도 있다.

#### 그 이외의 헤더 필드

웹 서버의 브라우저의 기능 필요에 의해 독자적으로 확장된 HTTP 헤더 필드들이 존재한다.

* 쿠키를 위한 헤더 필드들.
* X-Frame-Option : 다른 웹 사이트의 프레임에서 표시를 제어하는 응답 헤더이다.
  * 클릭 재킹 공격을 막는 목적이다.
* X-XSS-Protection : 브라우저의 크로스 사이트 스크립팅(XSS) 보호 기능을 제어하는 응답 헤더이다.
* DNT : 개인 정보 수집에 대한 의사를 나타내는 요청 헤더이다.
* P3P : 웹 사이트의 상의 프라이버시 정책에 P3P를 사용하는 것으로, 프로그램이 읽을 수 있는 형태로 나타내기 위한 응답 헤더이다.

<br>

## 8. 웹을 안전하게 지켜주는 HTTPS

#### HTTP의 약점

HTTP는 보안상 여러 취약점들이 존재한다.

* TCP/IP는 평문 통신이기 때문에 도청이 가능하다.
* 요청 및 응답 등의 통신 상대를 확인하지 않기 때문에 위장이 가능하다.
* 완전성을 증명할 수 없기 때문에 변조가 가능하다.
  * 응답과 요청이 전달되는 과정의 중간에서 변조되어도 송신자와 수신자는 알 방법이 없다.
  * 디지털 서명 혹은 MD5나 SHA-1 등의 해시 값을 확인하는 방법 등으로 방지할 수 있으나 확신할 수 없다.

#### HTTPS

HTTPS란 HTTP에 암호화와 인증 및 완전성 등의 보호 구조를 더한 것이다. HTTP와 TCP 사이에 SSL이나 TLS같은 프로토콜이 추가된 형태이다. HTTP는 TCP와 통신하지만, SSL을 사용하면 HTTP는 SSL과 통신하고 SSL이 TCP와 통신한다.

* 공통키(대칭키) 방식.
  * 클라이언트와 서버가 한 개의 키로 암호화 및 복호화하는 방식이다.
  * 키를 전달하는 과정에서 탈취당하면 암호화의 의미가 없어진다.
* 공개키(비대칭키) 방식.
  * 공개키와 비밀키가 1개의 쌍을 이룬다.
  * 한 쪽의 키로 암호화하면 다른 한 쪽의 키로만 복호화할 수 있다.
    * 공개키로 암호화한 것은 비밀키로만 복호화할 수 있기 때문에 도청이 불가능하다.
    * 비밀키로 암호화한 것은 공개키로만 복호화할 수 있기 때문에 신분 증명 용도로 사용된다.

HTTPS는 공개키와 공통키를 모두 사용하는 하이브리드 암호 시스템이다. 공개키 방식은 공통키 방식에 비해 처리 속도가 늦기 때문에, 키를 교환할 때만 공개키를 사용하고 통신할 때는 공통키를 사용한다.

* 서버는 공개키를 제 3자 인증기관인 CA에 등록한다.
* CA는 CA의 비밀키로 서버의 공개키에 대한 디지털 서명 증명서를 발급(즉, 암호화)한다.
* 클라이언트가 서버에 HTTPS 통신을 요청하면, 서버는 서버의 공개키와 증명서를 응답으로 보낸다.
* 클라이언트는 사전에 브라우저에 저장된 CA의 공개키로 증명서가 진짜인지 확인(즉, 복호화)한다.
* 클라이언트는 서버의 공개키로 통신에 사용할 공통키를 암호화하여 전달한다.
* 서버는 서버의 비밀키로 메시지를 복호화하여 공통키를 획득한다.
* 이후 서버와 클라이언트는 공통키로 메시지를 암호화-복호화하여 안전하게 통신한다.

클라이언트 또한 클라이언트 증명서를 통해 인증을 할 수 있으나, 클라이언트마다 증명서를 발급하기에는 비용이 비싸기 때문에 제한적으로 사용된다. 또한 클라이언트 증명서가 담긴 컴퓨터에 대해 사용 권한이 있는 사람 모두가 증명서를 이용할 수 있다는 단점이 있다.

HTTPS는 SSL 암호화 및 복호화로 인해 통신 속도가 떨어지고 CPU나 메모리 등의 리소스를 많이 소비한다. SSL 엑셀레이터같은 하드웨어를 사용하거나, 민감한 정보를 포함하지 않는 통신에서는 HTTP를 사용하는 등의 방식을 통해 부하를 분산한다.

<br>

## 9. 누가 액세스하고 있는지를 확인하는 인증

인증이란 액세스하고 있는 대상이 누구인지를 확인하는 작업이다.

#### BASIC 인증

BASIC 인증은 Base64 인코딩 형식을 사용하지만 아무런 부가 정보 없이 복호화가 가능하기 때문에 도청 가능성이 높다. 또한 한 번 BASIC 인증을 하면 일반 브라우저에서는 로그아웃할 수 없다. 여러 이슈들로 인해 그다지 사용되지 않는 방식이다.

* BASIC 인증이 필요한 리소스에 리퀘스트하면 서버는 401 Authorization Required 응답을 보낸다.
  * WWW-Authenticate 헤더 필드에 인증 방식과 Realm을 추가한다.
* 클라이언트는 Authorization 필드에 아이디와 패스워드 등을 Base64로 인코딩해 보낸다.
* 서버는 인증에 성공하면 200 응답을, 실패하면 401 응답을 반환한다.

#### DIGEST 인증

DIGEST 인증 방식은 챌린지 리스폰스를 사용하여 BASIC 인증의 약점을 보완한다. 그러나 위장 방지 기능 미지원 등 HTTPS에 비해 여전히 보안 등급이 낮아 그다지 사용되지 않는 방식이다.

* 인증이 필요한 리소스에 리퀘스트하면 서버는 401 상태 코드로 응답하면서 패스워드와 챌린지 코드(nonce)를 송신한다.
* 클라이언트는 패스워드와 챌린지 코드에서 리스폰스 코드를 계산하여 송신한다.
* 서버는 인증에 성공하면 200 응답을, 실패하면 401 응답을 반환한다.

#### SSL 클라이언트 인증

SSL 클라이언트 인증 방식은 **8절**에서 언급한 것 처럼 비용이 비싸며, 클라이언트의 컴퓨터만을 인증할 뿐 실제 사용자는 다를 수 있다. 때문에 폼 베이스 인증과 합쳐서 2-factor 인증에서 사용된다. SSL 클라이언트 인증 후, 패스워드 등 이용자의 다른 인증 정보를 통해 사용자 본인 확인도 진행한다.

#### 폼 베이스 인증

BASIC과 DIGEST 등의 HTTP 표준 인증 방식이나 SSL 클라이언트 인증 방식은 한계가 많아 범용적으로 사용하기 어렵다. 웹 사이트의 인증 기능으로서 요구되는 기능의 레벨을 충족시키는 표준 방식이 없기 때문에, 대부분의 웹 어플리케이션은 클라이언트가 패스워드 등 자격 정보를 입력하는 폼 베이스 인증을 채택한다.

그러나 폼 베이스 인증에서도 자격 정보를 교환하는 방법은 표준화되어 있지 않다. 웹 어플리케이션마다 인증의 보안 수준이 상이하다. 다음은 보안 취약 사례이다.

* 폼 베이스 인증 과정 이후 상태 관리를 위해 쿠키-세션을 사용하는 도중 세션 ID가 탈취되는 경우.
* 클라이언트의 자격 정보를 암호화하지 않고 평문으로 서버에 저장하는 경우.

<br>

## 10. HTTP에 기능을 추가한 프로토콜

#### 기존 HTTP의 한계

인터넷 사용자가 많아짐에 따라 단시간에 대량의 데이터들이 새로 서버에 갱신된다. 서버에 정보가 갱신되었을 때 클라이언트의 화면 또한 실시간으로 갱신되어야 한다. 클라이언트는 서버의 정보가 갱신되었는지 아닌지 항상 확인해야 하고, 갱신되지 않은 경우 불필요한 통신이 발생한다. 다음과 같은 HTTP 사양의 한계로 인해 HTTP의 병목 현상이 발생한다.

* 1개의 커넥션으로 1개의 요청만 보낼 수 있다.
* 요청은 클라이언트만 시작이 가능하고, 응답만 받는 것은 불가능하다.
* 요청/응답 헤더를 압축하지 않기 때문에 헤더의 정보가 많을 수록 지연이 심해진다.
* 매번 같은 장황한 헤더를 반복되게 보내 낭비가 발생한다.
* 데이터 압축은 선택 사항일 뿐, 강제하지 않는다.

#### 대안 1 : Ajax

Ajax(Asynchronous JavaScript + XML)는 JS나 DOM 조작 등을 활용해 웹 페이지 일부분만 고쳐 쓰는 비동기 통신 방법이다.

* 클라이언트가 갱신 상황을 확인하는 요청을 보낸다.
  * 기존의 동기식 통신에서 서버는 데이터가 갱신되면 페이지 전체의 데이터를 응답으로 보낸다.
* Ajax는 페이지에서 갱신된 부분의 데이터만을 전송하기 때문에 전송량이 줄어든다.

그러나 Ajax 또한 계속 갱신 상황이 있는지 확인해야 하기 때문에 대량의 HTTP 요청이 발생한다.

#### 대안 2 : Comet

Comet은 서버 측의 콘텐츠에 갱신이 있을 때, 클라이언트로부터 요청을 기다리지 않고 클라이언트에게 보내기 위한 방법이다. 통상 갱신 확인 요청이 들어오면 서버는 바로 응답을 반환하지만, Comet은 응답을 보류 상태로 해두고 서버의 콘텐츠가 갱신되었을 때 응답을 반환한다. 응답을 연장함으로써 서버 푸시 기능을 유사하게 구현한다.

그러나 응답을 보류하기 위해 연결을 유지하는 시간이 길어지며 리소스를 낭비하게 된다. 또한 Ajax와 마찬가지로 매번 같은 헤더의 요청을 보내는 등 HTTP 자체의 한계를 극복하지 못한다.

#### SPDY

SPDY는 HTTP가 안고 있던 병목 현상을 프로토콜 레벨에서 해소하기 위한 프로토콜이다. HTTP(어플리케이션 계층)와 SSL(프레젠테이션 계층) 사이의 세션 계층에서 작동한다. SSL 위에서 동작하도록 표준화되어 있다. 세션으로서 데이터 흐름을 제어하지만, HTTP의 커넥션이 확립되어 있기 때문에 다양한 HTTP 프로토콜 기능을 사용할 수 있다.

* 다중화 스트림.
  * 단일 TCP 접속으로 복수의 HTTP 리퀘스트를 무제한 처리할 수 있다.
* 리퀘스트의 우선 순위 부여.
  * 복수의 리퀘스트를 보낼 때 대역폭이 좁으면 처리가 늦어지는 병목을 해결한다.
* 서버 푸시 기능.
  * 서버 측은 클라이언트 요청을 기다리지 않고 데이터를 보낸다.
* 서버 힌트 기능.
  * 클라이언트에게 요청해야 할 리소스를 제안한다.
* HTTP 헤더 압축.

그러나 SPDY는 한 개의 도메인과의 통신을 다중화하기 때문에 하나의 웹 사이트에서 여러 개의 도메인으로 리소스를 사용하는 경우 효과가 한정적이다.

#### WebSocket

WebSocket은 새로운 프로토콜과 API를 통해 HTTP 병목 문제를 해결하기 위한 기술로서 개발되었다.

서버와 클라이언트가 한 번 접속을 확립하면 그 뒤 모든 통신을 전용 프로토콜로 진행한다. 서버와 클라이언트 어느 쪽에서도 송신이 가능한 양방향 통신이다.

* 서버 푸시 기능.
  * 클라이언트의 요청을 기다릴 필요가 없어진다.
* 통신량의 삭감.
  * HTTP에 비해 자주 접속하는 오버헤드가 적다.
  * HTTP에 비해 헤더의 크기가 작아 통신량을 줄일 수 있다.
* 핸드쉐이크.
  * HTTP Upgrade 헤더를 사용하여 WebSocket 프로토콜 사용을 합의한다.
  * 이후 독자적인 데이터 프레임으로 클라이언트와 서버가 통신한다.

HTTP/2.0은 웹과 모바일에서의 성능 향상을 위해 SPDY 및 WebSocket을 활용한 프토토콜 규격 개선을 논의 중이다.

#### WebDAV

WebDAV는 웹 서버의 콘텐츠에 대해 직접 파일 복사나 편집 작업 등을 관리할 수 있는 분산 파일 시스템이다. DELETE, PUT 메서드는 보안 및 편의성의 이슈로 사용하지 않는다. HTTP/1.1에는 WebDAV를 위한 메서드 및 상태 코드가 추가되었다.


* 컬렉션 : 여러 개의 리소스를 한꺼번에 관리하기 위한 개념이다.
* 자원 : 파일이나 컬렉션을 리소스라고 부른다.
* 프로퍼티 : 리소스의 프로터피는 Key-Value 형식으로 정의한다.
* 잠금 : WebDAV는 파일의 잠금을 설정할 수 있다.

<br>

## 11. 웹 콘텐츠에서 사용하는 기술

웹 페이지는 대부분 HTML로 이루어져 있으며, CSS가 디자인을 관장한다.

#### Dynamic HTML

클라이언트 사이드 스크립트를 사용해서 HTML 내용을 동적으로 변경하는 기술이다.

* DOM(Document Object Model) : HTML 내의 요소를 오브젝트로 다룬다.
  * JS와 함께 사용함으로써 HTML을 쉽게 조작할 수 있다.

#### 웹 어플리케이션

웹 어플리케이션은 웹 기능을 사용해서 제공되는 프로그램을 지칭한다. 과거에는 정적으로 준비된 컨텐츠를 클라이언트에게 제공했으나, 웹의 보급으로 인해 클라이언트 요청에 맞게 콘텐츠를 동적으로 생성해서 보여줄 필요성이 증대되었다.

#### CGI

CGI(Common Gateway Interface)는 웹 서버가 클라이언트에서 받은 요청을 프로그램에 전달하기 위한 구조이다. CGI를 사용하는 프로그램은 요청 내용에 맞게 HTML을 생성하는 등 동적 컨텐츠 생성이 가능하다. 그러나 CGI는 요청마다 프로그램을 기동하기 때문에 대량의 액세스가 있을 때 웹 서버에 부하가 심해진다.

#### Java Servlet

Java Servlet은 서버 상에서 HTML 등 동적 컨텐츠를 생성하기 위한 프로그램이다. 서블릿은 웹 서버가 직접 프로그램을 실행하는 구조이다. 서블릿의 실행 환경을 서블릿 컨테이너라고 한다. 서블릿 컨테이너(웹 컨테이너)가 웹 서버와 같은 프로세스에서 동작하기 때문에 부하가 적다.

#### 데이터 송신에 이용되는 포맷 및 언어

* XML(eXtensible Markup Language) : 데이터 공유 등의 목적에 맞게 확장 가능한 마크업 언어이다.
* RSS/Atom : 뉴스 블로그 기사 등 갱신 정보를 송신하기 위한 포맷의 총칭으로 XML을 사용한다.
* JSON(JavaScript Object Notation) : 경량 데이터 기술 언어로서 오브젝트 표기법을 바탕으로 한다.
  * 데이터를 단순하고 가볍게 읽을 수 있다는 점에서 널리 이용 중이다.

<br>

## 12. 웹 공격 기술

* 능동적 공격 : 공격자가 직접 웹 어플리케이션에 액세스하여 공격 코드를 보낸다.
* 수동적 공격 : 함정을 이용해 유저에게 공격 코드를 실행시키는 공격이다.

보안 대책을 실시하는 장소는 클라이언트 사이드, 어플리케이션 사이드(입력값 체크, 출력값 체크) 등이 있다.

#### 출력 값의 이스케이프 미비로 인한 취약성

출력값 이스케이프가 미비한 경우, 공격자가 보낸 코드가 출력하는 대상에 피해가 갈 수 있다.

* 크로스 사이트 스크립팅(XSS).
  * 취약성이 있는 웹 사이트를 방문한 사용자의 브라우저에 부정한 HTML 태그나 JS 등을 동작시키는 공격이다.
* SQL 인젝션.
  * 웹 어플리케이션을 이용하고 있는 DB에 SQL을 부정하게 실행한다.
  * 개발자가 의도하지 않는 형태로 SQL 문장이 변경되어 구조가 파괴되는 공격이다.
* OS 커맨드 인젝션.
  * 웹 어플리케이션을 경유하여 OS 명령을 부정하게 실행하는 공격이다.
* HTTP 헤더 인젝션.
  * 공격자가 응답 헤더 필드에 개행 문자 등을 삽입함으로써 임의의 리스폰스 헤더 필드나 바디를 추가하는 공격이다.
  * 부정하게 쿠키를 획득하는 등 세션 픽세이션에 이용된다.
* 메일 헤더 인젝션.
  * 메일 송신 기능에 공격자가 TO, SUBJECT 등의 헤더를 부정하게 추가하는 공격이다.
  * 스팸 메일 송신에 이용된다.
* 디렉토리 트래버설.
  * 패스워드 파일 등 비공개 디렉토리 파일에 대해 부정하게 경로를 가로질러 액세스한다.
* 리모트 파일 인클루드.
  * 스크립트 일부를 다른 파일에서 읽어올 때, 공격자가 지정한 외부 서버 URL을 읽게 함으로써 공격 스크립트를 동작시킨다.

#### 웹 서버 설정 및 설계 미비로 인한 취약성

* 강제 브라우징.
  * 웹 서버 공개 디렉토리 파일 중 공개 의도가 없는 파일이 열람되게 하는 취약성이다.
* 부적절한 에러 메시지.
  * 공격자에게 유익한 정보가 웹 어플리케이션 에러 메시지에 포함되는 취약성이다.
* 오픈 리다이렉트.
  * 지정한 임의의 URL로 리다이렉트 하는 기능이지만 악의가 있는 사이트로 연결될 수 있는 취약성이 존재한다.

#### 세션 관리 미비로 인한 취약성

* 세션 하이잭.
  * 공격자가 쿠키 등에 있는 세션 ID를 탈취하여 해당 유저로 위장한다.
* 세션 픽세이션.
  * 공격자가 지정한 세션 ID를 다른 유저에게 강제적으로 사용하게 한다.
    * 다른 유저가 해당 세션 ID로 인증하게 되면, 공격자는 해당 유저로 위장하여 서버에 액세스할 수 있다.
* 크로스 사이트 리퀘스트 포저리(CSRF).
  * 공격자가 설치해 둔 함정에 의해 인증된 유저가 개인정보/설정 등을 어떤 상태로 갱신하는 처리를 강제로 실행하게 하는 공격이다.

#### 기타

* 패스워드 크래킹.
  * 패스워드를 논리적으로 이끌어내서 인증을 돌파하는 방식이다.
  * 브루트 포스, 사전 공격, 알고리즘 취약성, 복호화키 확보, 레인보우 테이블 등 다양한 방법을 통해 인증을 돌파한다.
* 클릭 재킹.
  * IFRAME를 활용한 투명한 버튼이나 링크 등의 함정을 웹 페이지에 심어두고, 유저가 링크를 클릭하게함으로써 의도하지 않은 콘텐츠에 액세스 시키는 공격이다.
* Dos(Denial of Service Attack).
  * 서비스 제공을 정지 상태로 만드는 공격이다.
    * 타깃 서버에 대해 대량의 액세스 트래픽을 집중시킴으로써 해당 서비스가 리소스를 모두 소모하게 만든다.
    * 혹은 취약성을 공격해 서비스를 정지시킨다.
  * 봇들을 동원하는 경우 DDoS(Distributed Denial of Service Attack)이라고 한다.
* 백도어.
  * 제한된 기능을 정규 절차 없이 사용하기 위해 설치된 뒷문이다.
  * 공격자가 설치하는 것 이외에도, 개발자가 개발 단계에서 디버깅 목적으로 설치할 수 있다.

<br>

---

## Reference

* 그림으로 배우는 HTTP & Network Basic(우에노 센 저)
