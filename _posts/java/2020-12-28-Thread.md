---
title: "[Java] Thread 정리"
categories:
  - Java
tags:
  - Java
toc: true
toc_sticky: true
last_modified_at: 2020-12-28T20:05:00-05:00
---

Thread
------

-	Process는 실행 중인 프로그램이며, 프로그램을 실행하면 OS로부터 실행에 필요한 자원인 메모리를 할당받아 프로세스가 된다.<br><br>
-	프로세스는 프로그램 수행에 필요한 데이터와 메모리 등의 자원 그리고 쓰레드로 구성되어 있다.<br><br>
-	자원을 이용해 실제 작업을 수행하는 것이 쓰레드이다.<br><br>
-	프로세스가 가질 수 있는 쓰레드의 개수는 제한이 없으나, 쓰레드가 작업을 수행하는 개별적인 메모리 공간인 호출 스택을 필요하기 때문에 메모리 한계에 따른 쓰레드의 수가 결정된다.<br><br>
-	CPU 코어가 한 번에 단 하나의 작업만 수행할 수 있으므로, 실제로 동시에 처리되는 작업의 개수는 코어의 개수와 일치한다.<br><br>
-	멀티 쓰레딩은 CPU 사용률 향상, 자원의 효율적 사용, 응답성 향상, 작업 분리를 통한 코드 간결화 등의 장점이 있다.<br><br>
-	그러나 동기화 및 교착 상태의 문제 등이 발생할 수 있다.<br><br>

쓰레드 구현 및 실행
-------------------

```java
ThreadEx1_1 t1 = new ThreadEx1_1(); //Thread 클래스 상속
Runnable r = new ThreadEX1_2();
Thread t2 = new Thread(r); //Runnable 인터페이스 구현
t2.start();
```

-	Thread 클래스를 상속받거나 Runnable 인터페이스를 구현한다.<br><br>
-	클래스 내부의 `run()` 메서드에 실행 내용을 기술하며, `start()` 메서드로 쓰레드를 실행한다.<br><br>
-	한 번 종료된 쓰레드는 다시 실행이 불가능하며, 새롭게 객체를 생성해야 한다.<br><br>
-	`start()` 메서드는 새로운 쓰레드가 작업하는 호출 스택을 생성하고, `run()` 을 호출하여 생성된 호출 스택에 `run()` 을 올린다.<br><br>
-	모든 쓰레드는 독립적인 작업을 수행하기 위해 자신만의 호출 스택이 필요하기 때문에, 쓰레드의 생성과 종료마다 새 호출 스택이 생성 및 소멸된다.<br><br>
-	스케쥴러에 의해 번갈아 가면서 작업이 실행되며, 자신의 순서가 아니면 최상위에 있는 메서드일지라도 대기 상태가 된다.<br><br>
-	실행 중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료된다.<br><br>

싱글 쓰레드와 멀티 쓰레드
-------------------------

-	하나의 쓰레드와 두 개의 쓰레드로 작업을 수행하면, 시간은 거의 비슷하게 소요된다.<br><br>
-	오히려 멀티 쓰레드는 쓰레드 간의 작업 전환으로 인해 시간이 더 걸린다.<br><br>
-	쓰레드도 JVM의 쓰레드 스케쥴러에 의해 영향을 받듯, 프로세스도 OS의 프로세스 스케쥴러에 영향을 받는다.<br><br>
-	Java가 OS 독립적이라고 하지만 쓰레드는 프로세스 및 쓰레드에게 할당되는 시간이 OS에 의해 불확실하기 때문에 다소 종속적인 부분이다.<br><br>
-	두 쓰레드가 서로 다른 자원을 사용하는 작업의 경우 멀티 쓰레드 프로세스가 더 효율적이다.<br><br>

쓰레드의 우선순위
-----------------

```java
void setPriority(int newPriority) //우선순위 지정
int getPriority() //우선순위 반환
```

-	쓰레드는 우선순위라는 멤버 변수를 가지고 있으며, 높을 수록 중요도가 높아 쓰레드가 얻는 실행 시간이 달라진다.<br><br>
-	우선순위의 범위는 1부터 10이며, 메인 쓰레드는 5의 보통 값을 가진다.<br><br>
-	그러나 이 역시 스케쥴러에 의해 불확실성을 가지고 있다.<br><br>

쓰레드 그룹
-----------

-	쓰레드 그룹은 서로 관련된 쓰레드를 그룹으로 다루기 위한 것이다.<br><br>
-	폴더 안에 폴더를 생성할 수 있듯이, 쓰레드 그룹에 다른 쓰데르 그룹을 포함시킬 수 있다.<br><br>

데몬 쓰레드
-----------

```java
boolean isDaemon() //데몬 쓰레드 여부 판별
void setDaemon(boolean on) //true시 데몬 쓰레드로 변경
```

-	데몬 쓰레드는 다른 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드이다.<br><br>
-	일반 쓰레드가 모두 종료되면 데몬 쓰레드는 강제 자동 종료가 된다.<br><br>
-	가비지 컬렉터, 자동 저장, 화면 자동 갱신 등이 그 예이다.<br><br>
-	쓰레드를 실행하기 전, `setDaemon(true)` 를 호출하면 되며, 데몬 쓰레드가 생성한 쓰레드는 자동적으로 데몬 쓰레드가 된다.<br><br>

쓰레드의 실행 제어
------------------

![image](https://user-images.githubusercontent.com/56240505/72275798-fbaf5e80-3671-11ea-9b9d-faae4e9bc5f9.png)<br><br> ![image](https://user-images.githubusercontent.com/56240505/72275824-0d910180-3672-11ea-9687-6d3141486a65.png)<br><br> ![image](https://user-images.githubusercontent.com/56240505/72275858-21d4fe80-3672-11ea-9b1a-fd44a822c9cf.png)<br><br>

-	`resume()`, `stop()`, `suspend()` 메서드는 교착 상태 이슈로 deprecated 되었다.<br><br>

쓰레드의 동기화
---------------

-	멀티 쓰레드의 경우 자원을 공유하면서 원하지 않는 결과를 얻을 수 있다.<br><br>
-	공유 데이터를 사용하는 코드 영역을 임계 영역으로 지정하고, 공유 데이터가 가지고 있는 lock을 획득한 단 하나의 쓰레드만 코드를 수행할 수 있게 한다.<br><br>
-	한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것을 쓰레드의 동기화라고 한다.<br><br>

synchronized
------------

```Java
public synchronized void calcSum() //메서드 전체를 임계 영역 지정
synchronized(객체 참조변수){
  ...
} //특정 영역을 임계 영역 지정
```

-	참조변수는 락을 걸고자 하는 객체를 참조하는 것이어야 한다.<br><br>

wait() & notify() & notifyAll()
-------------------------------

-	특정 쓰레드가 객체의 락을 가진 상태로 오랜 시간을 보내지 않도록 하는 것도 중요하다.<br><br>
-	임계 영역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니면 `wait()` 을 호출하여 쓰레드가 락을 반납하고 기다리게 한다.<br><br>
-	나중에 작업을 진행할 수 있는 상황이 되면 `notify()` 를 호출하여 다시 락을 얻어 작업을 진행시킨다.<br><br>
-	Object 클래스에 정의되어 있으며, 동기화 블록 내에서만 사용이 가능하다.<br><br>
-	waiting pool은 객체마다 존재하기 때문에, 해당 메서드들은 호출된 객체의 waiting pool에만 관여한다.<br><br>

기아 현상과 경쟁 상태
---------------------

-	운이 나쁜 일부 쓰레드는 계속 통지를 받지 못하고 오랫동안 기다리게 된다.<br><br>
-	여러 쓰레드가 lock을 받기 위해 경쟁하는 것을 경쟁 상태라고 한다.<br><br>

Lock과 Condition을 이용한 동기화
--------------------------------

-	java.util.concurrent.locks 패키지가 제공하는 lock 클래스들을 이용하여 동기화할 수 있다.<br><br>
-	이를 통해 기아 현상 및 경쟁 상태를 해소할 수 있다.<br><br>

volatile
--------

```java
volatile boolean stopped = false;
volatile long tmp;
volatile double tmp2;
```

-	CPU 코어는 메모리에서 읽어온 값을 캐시에 저장하고, 캐시에서 값을 읽어 작업한다.<br><br>
-	같은 값을 읽어올 때는 먼저 캐시에 있는지 확인하고, 없을 때만 메모리에서 읽는다.<br><br>
-	메모리에 저장된 변수의 값이 변경되었는데도, 캐시에 저장된 값이 갱신되지 않아서 메모리에 저장된 값r과 다른 경우가 발생한다.<br><br>
-	volatile 키워드를 사용하면 코어가 변수의 값을 읽어올 때 캐시가 아닌 메모리에서 읽어오기 때문에 불일치가 해소된다.<br><br>
-	이는 synchronized 블럭의 사용과 효과가 동일하다.<br><br>
-	JVM은 데이터를 4 byte 단위로 처리하며, 4 byte 이하의 데이터는 단 하나의 명령어로 읽거나 쓰기나 가능하다.<br><br>
-	이 때문에 하나의 명령어는 최소의 작업 단위이며, 작업 중간에 다른 쓰레드가 끼어들 틈이 없다.<br><br>
-	8 byte의 자료형은 하나의 명령어로 값을 읽거나 쓸 수 없어, 다른 쓰레드가 끼어들 여지가 있다.<br><br>
-	따라서 volatile을 선언하여 해당 변수에 대한 읽기나 쓰기를 원자화시킨다.<br><br>
-	상수는 변하지 않는 값이므로 멀티 쓰레드에 안전하기 때문에 volatile을 붙이지 않는다.<br><br>
-	volatile은 원자화만 할 뿐, 동기화하는 것이 아니기 때문에 동기화에는 synchronized를 사용한다.<br><br>

fork & join 프레임웍
--------------------

-	프레임웍을 통해 하나의 작업을 작은 단위로 나눠서, 여러 쓰레드가 동시에 처리하는 것을 쉽게 만들어준다.<br><br>

---

Reference
---------

-	Java의 정석 (남궁성 저) Chapter 13
