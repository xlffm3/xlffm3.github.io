---
title: "[Effective Java] Item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라"
excerpt: "오토박싱은 박싱된 기본 타입의 위험까지 없애주지는 않는다."
categories:
  - Java
tags:
  - Java
  - Effective Java
date: 2021-02-08
last_modified_at: 2021-02-08
---

## 1. 박싱된 기본 타입

int, double, boolean 등의 기본 타입에 대응하는 참조 타입을 박싱된 기본 타입(Integer, Double, Boolean 등)이라고 한다.

오토박싱 및 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용이 가능하지만, 분명한 차이가 있기 때문에 주의해서 사용해야 한다.

<br>

## 2. 기본 타입과 박싱된 기본 타입의 차이점

### 2.1. 식별성

기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성을 갖는다. 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.

> BrokenComparator.java

```java
 Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
     int i = iBoxed, j = jBoxed;
     return i < j ? -1 : (i == j ? 0 : 1);
 };
 ```
* 두 Integer 인스턴스끼리 크기를 비교하는 \> 연산을 수행할 때는 정상적으로 오토박싱된다.
* 그러나 == 연산을 할 때는 값이 아닌 레퍼런스를 비교하기 때문에 원하는 결과가 나오지 않을 수 있다.
  * 위 코드처럼 Integer 매개변수의 값을 기본 타입 정수로 오토박싱한 다음 비교를 수행해야 한다.
* 실무에서 기본 타입을 다루는 비교자가 필요하다면 ``Comparator.naturalOrder()``를 사용한다.
  * 비교자를 만들면 ``compare()`` 메서드를 사용해야 한다.

### 2.2. null

박싱된 기본 타입은 유효하지 않은 값인 null을 가질 수 있다.

* 박싱된 기본 타입과 기본 타입을 비교할 때는 박싱된 기본 타입이 자동으로 오토 박싱된다.
  * ``박싱된 기본 타입 인스턴스 == 42``와 같은 연산에서 박싱된 기본 타입 인스턴스의 값이 null이라면?
    * ``null == 42``로 언박싱되면서 NPE가 발생한다.

### 2.3. 효율성

기본 타입은 박싱된 기본 타입보다 시간 및 메모리 사용면에서 더 효율적이다.

* 반복문에서 기본 타입과 박싱된 기본 타입을 혼용하면 박싱과 언박싱이 반복해서 일어나 성능 저하로 이어진다.

<br>

## 3. 박싱된 기본 타입 사용 경우

* 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 한다.
  * 자바 언어는 지네릭스의 타입 매개변수로 기본 타입을 지원하지 않는다.
* 리플렉션을 통해 메서드를 호출할 때 사용한다.

<br>

---

## Reference

* Effective Java 3/E(Joshua Bloch 저)
