---
title: "[Modern Java in Action] 1장. Java 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?"
excerpt: "새로운 언어가 탄생하고, 오래된 언어는 진화하지 못하면 도태된다."
categories:
  - Java
tags:
  - Java
  - Modern Java in Action
date: 2021-02-19
last_modified_at: 2021-02-19
---

## 1. Java의 변천사

* Java 1.0은 스레드와 락 및 메모리 모델 등을 통해 동시성을 지원했으나, 적절히 사용하기가 매우 어려웠다.
* Java 5는 스레드 풀 및 동시성 컬렉션 등을 제공하기 시작했다.
* Java 7은 포크-조인 프레임워크 등을 통해 동시성을 실용적으로 만들었으나 여전히 다루기 어려웠다.
* Java 8은 병렬화를 지원하는 간단한 방법을 제공하기 시작했다.
* Java 9는 반응형 프로그래밍을 통해 동시성 구조화를 위한 메서드를 추가했다.

### 1.1. Java 8의 새로운 API

Stream API를 통해 DB 쿼리 언어와 유사하게 데이터를 처리하는 다양한 병렬 작업을 지원한다. 비용이 비싸고 에러가 발생하기 쉬운 synchronized 제한어를 사용하지 않아도 된다.

* 메서드 참조 및 람다 표현식을 통해 코드를 정확하게 전달할 수 있다.
  * 함수형 프로그래밍을 통한 동적 파라미터화가 가능하다.
* 인터페이스에 디폴트 메서드 기능이 추가되었다.

<br>

## 2. 왜 Java는 여전히 변화하는가?

프로그래밍 언어란 생태계처럼 동작한다. 새로운 언어가 탄생하고, 오래된 언어는 진화하지 못하면 도태된다. 만능 언어란 존재하지 않고, 특정 언어는 특정 목표에 적합할 뿐이다.

* OOP는 캡슐화 규약 등으로 인해 C보다 소프트웨어 엔지니어링 이슈가 적었고, 쉬운 개발을 가능하게 도와준다.
  * Java는 모든 것을 객체로 보고, 한 번 작성하면 모든 곳에서 작동된다는 장점을 가진다.
* JVM에서 동작하는 Java는 인터넷 애플릿에 적합했으며 대학가 등에서 유명해졌다.
* 초기에는 스레드와 락 및 메모리 모델 등을 통해 작은 규모의 동시성을 지원했으나, 처리해야 할 데이터의 양이 많아지면서 멀티코어 효율성을 극대화하려는 수요가 많아졌다.
  * 변화에 발맞춰 Java는 병렬화를 지원한다.
* 최근 시스템들이 서로 다른 컴포넌트로 구성된 다양한 서브 컴포넌트 시스템을 통합하는 것은 흔하다.
  * 통합되는 컴포넌트들과 인터페이스 또한 변화가 필요하다.
  * 이러한 디자인 스타일을 위해 Java 8과 9는 각각 디폴트 메서드 및 모듈을 지원한다.

### 2.1. Stream Processing

Stream이란 개념적으로 한 번에 하나씩 생산되는 데이터 아이템들의 시퀀스이다. 한 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.

```bash
cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3
```

* 각각의 커맨드 라인들은 동시(concurrent)에 수행된다.
  * 앞의 cat이나 tr 명령어가 끝나지 않았더라도 sort는 입력으로 들어오는 초반 몇 줄의 스트림들을 처리할 수 있다.
* Java 또한 Stream API의 메서드 체이닝을 통해 위와 같은 파이프라인을 지원한다.
  * 스레드를 사용하는 것 보다 간편하게 멀티 코어를 활용하여 병렬 작업을 제공한다.
  * 한 번에 하나의 아이템을 순차적으로 처리하는 것 보다, 스트림 변환 작업을 구조화함으로써 더 높은 추상화 수준으로 코드를 작성할 수 있다.

### 2.2. 동적 파라미터화(Behavior Parameterization)

Java 8은 메서드를 다른 메서드의 인자로 전달함으로써 연산을 동적으로 파라미터화한다. 사과 리스트를 정렬하는데 정렬 기준은 계속 변경될 수 있다. 무게, 색깔, 크기 등. 그 때 마다 정렬 메서드를 새로 선언하는 것이 아니라, 정렬 메서드에 정렬 방법(메서드 코드)을 인수로 제공한다.

### 2.3. 병렬성(Parallelism)

병렬화 처리를 위해서는 다른 작업들과 동시에 수행되어도 안전한 동작(순수 함수)를 제공해야 한다. 순수 함수란 공유 가변 데이터에 접근하지 않는 사이드 이펙트가 없는 함수이다. Java 8 Stream API에서 제공하는 병렬성은 스레드 API를 직접 다루는 것보다 장점이 많다. 멀티코어 환경에서 synchronized를 사용하는 것은 어려우며, 코드들이 순차적으로 동작하도록 강제하기 때문에 비용이 비싸다.

### 2.4. 기타

* 지네릭스를 통해 컴파일타임에 잘못된 타입 에러를 체크하며 코드 또한 가독성이 우수해진다.
* 전통적인 OOP에서 함수형 프로그래밍 패러다임을 적극 도입했다.
  * 문제의 접근 방식이 How에서 What으로 변화되었다.

<br>

## 3. Functions

프로그래밍 언어의 핵심은 값을 조종하는 행위이다. 이러한 값들을 1급 시민(값, 객체)라고 한다. 그러나 프로그래밍 실행 중 값을 표현하는데 도움을 주지만 전달될 수 없는 것들을 2급 시민이라고 한다. 메서드와 클래스 등이 2급 시민에 해당한다.

런타임 때 메서드 코드를 1급 시민처럼 전달될 수 있게 만들면 프로그래밍에 있어서 상당한 유연함을 얻을 수 있다.

> Filter.java

```java
filterApple(list, new Predicate<Apple>() {
    @Override
    public boolean isHeavy(Apple apple) {
        return apple.getWeight() > 150;  
    }  
});

//익명 클래스를 다음과 같이 짧게 축약 가능

filterApple(list, (Apple apple) -> apple.getWeight() > 150);
filterApple(list, Apple::isHeavy);
```

* 메서드 참조 혹은 람다 표현식을 통해 메서드(함수) 코드를 값으로 활용해 전달한다.
  * 익명 클래스를 사용할 수 있다.

<br>

## 4. Streams

컬렉션이라면 for-each 대신 Stream API를 통해 복잡한 필터링 및 컬렉트 작업을 간단히 수행할 수 있다.

### 4.1. 멀티스레드

Java 어플리케이션은 기본적으로 싱글 코어 프로그램이다. 다른 코어들은 유휴 상태이거나, OS단의 다른 작업 등에 사용된다. Stream API는 작업을 나눈 뒤 각각의 코어들이 처리하게 하고 결과물을 병합하는 fork-join과 같은 병렬화 작업을 지원해준다.

* 컬렉션은 데이터를 저장하고 접근하는데 중점을 두며, 스트림은 데이터에 대한 연산이 초점이다.
* ``parallelStream()`` 등의 메서드를 통해 병렬성을 지원한다.
  * 큰 스트림을 여러 스트림으로 작게 쪼개서 병렬로 처리한다.

<br>

## 5. Default Method

Java 8 이전에는 인터페이스를 업데이트하려면 구현체 클래스들 또한 전부 수정해야 하는 단점이 존재했다. Java 8 부터는 인터페이스에 구현이 필요 없는 디폴트 메서드를 추가함으로써, 계속 진화할 수 있는 인터페이스를 지원할 수 있게 되었다.

Java 9는 여러 패키지들의 집합을 지닌 모듈을 정의할 수 있도록 지원한다. 이는 가시성과 이름공간을 잘 제어할 수 있도록 돕고, 간단한 JAR 형태의 컴포넌트 구조를 풍부하게 만들어준다.

<br>

## 6. 그 외

1. NPE를 피하기 위해 값을 포함하거나 포함하지 않는 컨테이너 객체인 Optional을 지원한다.
2. Java 8에서는 완벽하게 지원되지 않는 패턴 매칭에 대한 논의가 지속되고 있다.

```scala
def simplifyExpression(expr: Expr): Expr = expr match {
	case BinOp("+", e, Number(0)) => e  // 0 더하기
	case BinOp("*", e, Number(1)) => e  // 1 곱하기
	case BinOp("/", e, Number(1)) => e  // 1 나누기
	case _ => expr  // expr을 단순화할 수 없다
}
```

* 패턴 매칭은 컴파일러가 흔한 에러를 잡는데 도움을 준다.
  * 한 개 이상의 파라미터에 대한 멀티 매칭으로서, Java는 if-then-else 중첩을 통해 구현할 수 있다.
  * 정규 표현식과는 다른 개념이다.
* Java의 switch 문의 조건식은 기본형 및 String 자료형만 사용이 가능하다.
  * Scala 및 다양한 함수형 언어들은 switch 문에 다양한 자료형이 허용된다.

<br>

---

## Reference

* Modern Java in Action(Raoul-Gabriel Urma 저)
